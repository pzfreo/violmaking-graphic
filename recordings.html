---
layout: default
title: Recordings
header_type: base
header_img: "./assets/images/slice-of-a-viol.jpg"
og_image: "./assets/images/scroll.jpg"
subtitle: Video recordings of the stream    
---
<!DOCTYPE html>
<html class="staticrypt-html">
    <head>
        <meta charset="utf-8" />
        <title>Protected Page</title>
        <meta name="viewport" content="width=device-width, initial-scale=1" />

        <!-- do not cache this page -->
        <meta http-equiv="cache-control" content="max-age=0" />
        <meta http-equiv="cache-control" content="no-cache" />
        <meta http-equiv="expires" content="0" />
        <meta http-equiv="expires" content="Tue, 01 Jan 1980 1:00:00 GMT" />
        <meta http-equiv="pragma" content="no-cache" />

        <style>
            .staticrypt-hr {
                margin-top: 20px;
                margin-bottom: 20px;
                border: 0;
                border-top: 1px solid #eee;
            }

            .staticrypt-page {
                width: 360px;
                padding: 8% 0 0;
                margin: auto;
                box-sizing: border-box;
            }

            .staticrypt-form {
                position: relative;
                z-index: 1;
                background: #ffffff;
                max-width: 360px;
                margin: 0 auto 100px;
                padding: 45px;
                text-align: center;
                box-shadow: 0 0 20px 0 rgba(0, 0, 0, 0.2), 0 5px 5px 0 rgba(0, 0, 0, 0.24);
            }

            .staticrypt-form input[type="password"],
            input[type="text"] {
                background: inherit;
                border: 0;
                box-sizing: border-box; /* This ensures padding is included in the total width */
                font-size: 14px;
                outline: 0;
                padding: 15px 30px 15px 15px; /* Adjust the padding to ensure there is space for the icon */
                width: 100%;
            }

            .staticrypt-password-container {
                position: relative;
                outline: 0;
                background: #f2f2f2;
                width: 100%;
                border: 0;
                margin: 0 0 15px;
                box-sizing: border-box;
            }

            .staticrypt-toggle-password-visibility {
                cursor: pointer;
                height: 20px;
                opacity: 60%;
                padding: 13px;
                position: absolute;
                right: 0;
                top: 50%;
                transform: translateY(-50%);
                width: 20px;
            }

            .staticrypt-form .staticrypt-decrypt-button {
                text-transform: uppercase;
                outline: 0;
                background: #4CAF50;
                width: 100%;
                border: 0;
                padding: 15px;
                color: #ffffff;
                font-size: 14px;
                cursor: pointer;
            }

            .staticrypt-form .staticrypt-decrypt-button:hover,
            .staticrypt-form .staticrypt-decrypt-button:active,
            .staticrypt-form .staticrypt-decrypt-button:focus {
                background: #4CAF50;
                filter: brightness(92%);
            }

            .staticrypt-html {
                height: 100%;
            }

            .staticrypt-body {
                height: 100%;
                margin: 0;
            }

            .staticrypt-content {
                height: 100%;
                margin-bottom: 1em;
                background: #76B852;
                font-family: "Arial", sans-serif;
                -webkit-font-smoothing: antialiased;
                -moz-osx-font-smoothing: grayscale;
            }

            .staticrypt-instructions {
                margin-top: -1em;
                margin-bottom: 1em;
            }

            .staticrypt-title {
                font-size: 1.5em;
            }

            label.staticrypt-remember {
                display: flex;
                align-items: center;
                margin-bottom: 1em;
            }

            .staticrypt-remember input[type="checkbox"] {
                transform: scale(1.5);
                margin-right: 1em;
            }

            .hidden {
                display: none !important;
            }

            .staticrypt-spinner-container {
                height: 100%;
                display: flex;
                align-items: center;
                justify-content: center;
            }

            .staticrypt-spinner {
                display: inline-block;
                width: 2rem;
                height: 2rem;
                vertical-align: text-bottom;
                border: 0.25em solid gray;
                border-right-color: transparent;
                border-radius: 50%;
                -webkit-animation: spinner-border 0.75s linear infinite;
                animation: spinner-border 0.75s linear infinite;
                animation-duration: 0.75s;
                animation-timing-function: linear;
                animation-delay: 0s;
                animation-iteration-count: infinite;
                animation-direction: normal;
                animation-fill-mode: none;
                animation-play-state: running;
                animation-name: spinner-border;
            }

            @keyframes spinner-border {
                100% {
                    transform: rotate(360deg);
                }
            }
        </style>
    </head>

    <body class="staticrypt-body">
        <div id="staticrypt_loading" class="staticrypt-spinner-container">
            <div class="staticrypt-spinner"></div>
        </div>

        <div id="staticrypt_content" class="staticrypt-content hidden">
            <div class="staticrypt-page">
                <div class="staticrypt-form">
                    <div class="staticrypt-instructions">
                        <p class="staticrypt-title">Protected Page</p>
                        <p></p>
                    </div>

                    <hr class="staticrypt-hr" />

                    <form id="staticrypt-form" action="#" method="post">
                        <div class="staticrypt-password-container">
                            <input
                                id="staticrypt-password"
                                type="password"
                                name="password"
                                placeholder="Password"
                                autofocus
                            />

                            <img
                                class="staticrypt-toggle-password-visibility"
                                alt="template_toggle_show"
                                title="template_toggle_show"
                                src="data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg=="
                            />
                        </div>

                        <label id="staticrypt-remember-label" class="staticrypt-remember hidden">
                            <input id="staticrypt-remember" type="checkbox" name="remember" />
                            Remember me
                        </label>

                        <input type="submit" class="staticrypt-decrypt-button" value="DECRYPT" />
                    </form>
                </div>
            </div>
        </div>

        <script>
            // these variables will be filled when generating the file - the template format is 'variable_name'
            const staticryptInitiator = 
            ((function(){
  const exports = {};
  const cryptoEngine = ((function(){
  const exports = {};
  const { subtle } = crypto;

const IV_BITS = 16 * 8;
const HEX_BITS = 4;
const ENCRYPTION_ALGO = "AES-CBC";

/**
 * Translates between utf8 encoded hexadecimal strings
 * and Uint8Array bytes.
 */
const HexEncoder = {
    /**
     * hex string -> bytes
     * @param {string} hexString
     * @returns {Uint8Array}
     */
    parse: function (hexString) {
        if (hexString.length % 2 !== 0) throw "Invalid hexString";
        const arrayBuffer = new Uint8Array(hexString.length / 2);

        for (let i = 0; i < hexString.length; i += 2) {
            const byteValue = parseInt(hexString.substring(i, i + 2), 16);
            if (isNaN(byteValue)) {
                throw "Invalid hexString";
            }
            arrayBuffer[i / 2] = byteValue;
        }
        return arrayBuffer;
    },

    /**
     * bytes -> hex string
     * @param {Uint8Array} bytes
     * @returns {string}
     */
    stringify: function (bytes) {
        const hexBytes = [];

        for (let i = 0; i < bytes.length; ++i) {
            let byteString = bytes[i].toString(16);
            if (byteString.length < 2) {
                byteString = "0" + byteString;
            }
            hexBytes.push(byteString);
        }
        return hexBytes.join("");
    },
};

/**
 * Translates between utf8 strings and Uint8Array bytes.
 */
const UTF8Encoder = {
    parse: function (str) {
        return new TextEncoder().encode(str);
    },

    stringify: function (bytes) {
        return new TextDecoder().decode(bytes);
    },
};

/**
 * Salt and encrypt a msg with a password.
 */
async function encrypt(msg, hashedPassword) {
    // Must be 16 bytes, unpredictable, and preferably cryptographically random. However, it need not be secret.
    // https://developer.mozilla.org/en-US/docs/Web/API/SubtleCrypto/encrypt#parameters
    const iv = crypto.getRandomValues(new Uint8Array(IV_BITS / 8));

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["encrypt"]);

    const encrypted = await subtle.encrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        UTF8Encoder.parse(msg)
    );

    // iv will be 32 hex characters, we prepend it to the ciphertext for use in decryption
    return HexEncoder.stringify(iv) + HexEncoder.stringify(new Uint8Array(encrypted));
}
exports.encrypt = encrypt;

/**
 * Decrypt a salted msg using a password.
 *
 * @param {string} encryptedMsg
 * @param {string} hashedPassword
 * @returns {Promise<string>}
 */
async function decrypt(encryptedMsg, hashedPassword) {
    const ivLength = IV_BITS / HEX_BITS;
    const iv = HexEncoder.parse(encryptedMsg.substring(0, ivLength));
    const encrypted = encryptedMsg.substring(ivLength);

    const key = await subtle.importKey("raw", HexEncoder.parse(hashedPassword), ENCRYPTION_ALGO, false, ["decrypt"]);

    const outBuffer = await subtle.decrypt(
        {
            name: ENCRYPTION_ALGO,
            iv: iv,
        },
        key,
        HexEncoder.parse(encrypted)
    );

    return UTF8Encoder.stringify(new Uint8Array(outBuffer));
}
exports.decrypt = decrypt;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
async function hashPassword(password, salt) {
    // we hash the password in multiple steps, each adding more iterations. This is because we used to allow less
    // iterations, so for backward compatibility reasons, we need to support going from that to more iterations.
    let hashedPassword = await hashLegacyRound(password, salt);

    hashedPassword = await hashSecondRound(hashedPassword, salt);

    return hashThirdRound(hashedPassword, salt);
}
exports.hashPassword = hashPassword;

/**
 * This hashes the password with 1k iterations. This is a low number, we need this function to support backwards
 * compatibility.
 *
 * @param {string} password
 * @param {string} salt
 * @returns {Promise<string>}
 */
function hashLegacyRound(password, salt) {
    return pbkdf2(password, salt, 1000, "SHA-1");
}
exports.hashLegacyRound = hashLegacyRound;

/**
 * Add a second round of iterations. This is because we used to use 1k, so for backwards compatibility with
 * remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashSecondRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 14000, "SHA-256");
}
exports.hashSecondRound = hashSecondRound;

/**
 * Add a third round of iterations to bring total number to 600k. This is because we used to use 1k, then 15k, so for
 * backwards compatibility with remember-me/autodecrypt links, we need to support going from that to more iterations.
 *
 * @param hashedPassword
 * @param salt
 * @returns {Promise<string>}
 */
function hashThirdRound(hashedPassword, salt) {
    return pbkdf2(hashedPassword, salt, 585000, "SHA-256");
}
exports.hashThirdRound = hashThirdRound;

/**
 * Salt and hash the password so it can be stored in localStorage without opening a password reuse vulnerability.
 *
 * @param {string} password
 * @param {string} salt
 * @param {int} iterations
 * @param {string} hashAlgorithm
 * @returns {Promise<string>}
 */
async function pbkdf2(password, salt, iterations, hashAlgorithm) {
    const key = await subtle.importKey("raw", UTF8Encoder.parse(password), "PBKDF2", false, ["deriveBits"]);

    const keyBytes = await subtle.deriveBits(
        {
            name: "PBKDF2",
            hash: hashAlgorithm,
            iterations,
            salt: UTF8Encoder.parse(salt),
        },
        key,
        256
    );

    return HexEncoder.stringify(new Uint8Array(keyBytes));
}

function generateRandomSalt() {
    const bytes = crypto.getRandomValues(new Uint8Array(128 / 8));

    return HexEncoder.stringify(new Uint8Array(bytes));
}
exports.generateRandomSalt = generateRandomSalt;

async function signMessage(hashedPassword, message) {
    const key = await subtle.importKey(
        "raw",
        HexEncoder.parse(hashedPassword),
        {
            name: "HMAC",
            hash: "SHA-256",
        },
        false,
        ["sign"]
    );
    const signature = await subtle.sign("HMAC", key, UTF8Encoder.parse(message));

    return HexEncoder.stringify(new Uint8Array(signature));
}
exports.signMessage = signMessage;

function getRandomAlphanum() {
    const possibleCharacters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789";

    let byteArray;
    let parsedInt;

    // Keep generating new random bytes until we get a value that falls
    // within a range that can be evenly divided by possibleCharacters.length
    do {
        byteArray = crypto.getRandomValues(new Uint8Array(1));
        // extract the lowest byte to get an int from 0 to 255 (probably unnecessary, since we're only generating 1 byte)
        parsedInt = byteArray[0] & 0xff;
    } while (parsedInt >= 256 - (256 % possibleCharacters.length));

    // Take the modulo of the parsed integer to get a random number between 0 and totalLength - 1
    const randomIndex = parsedInt % possibleCharacters.length;

    return possibleCharacters[randomIndex];
}

/**
 * Generate a random string of a given length.
 *
 * @param {int} length
 * @returns {string}
 */
function generateRandomString(length) {
    let randomString = "";

    for (let i = 0; i < length; i++) {
        randomString += getRandomAlphanum();
    }

    return randomString;
}
exports.generateRandomString = generateRandomString;

  return exports;
})());
const codec = ((function(){
  const exports = {};
  /**
 * Initialize the codec with the provided cryptoEngine - this return functions to encode and decode messages.
 *
 * @param cryptoEngine - the engine to use for encryption / decryption
 */
function init(cryptoEngine) {
    const exports = {};

    /**
     * Top-level function for encoding a message.
     * Includes password hashing, encryption, and signing.
     *
     * @param {string} msg
     * @param {string} password
     * @param {string} salt
     *
     * @returns {string} The encoded text
     */
    async function encode(msg, password, salt) {
        const hashedPassword = await cryptoEngine.hashPassword(password, salt);

        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encode = encode;

    /**
     * Encode using a password that has already been hashed. This is useful to encode multiple messages in a row, that way
     * we don't need to hash the password multiple times.
     *
     * @param {string} msg
     * @param {string} hashedPassword
     *
     * @returns {string} The encoded text
     */
    async function encodeWithHashedPassword(msg, hashedPassword) {
        const encrypted = await cryptoEngine.encrypt(msg, hashedPassword);

        // we use the hashed password in the HMAC because this is effectively what will be used a password (so we can store
        // it in localStorage safely, we don't use the clear text password)
        const hmac = await cryptoEngine.signMessage(hashedPassword, encrypted);

        return hmac + encrypted;
    }
    exports.encodeWithHashedPassword = encodeWithHashedPassword;

    /**
     * Top-level function for decoding a message.
     * Includes signature check and decryption.
     *
     * @param {string} signedMsg
     * @param {string} hashedPassword
     * @param {string} salt
     * @param {int} backwardCompatibleAttempt
     * @param {string} originalPassword
     *
     * @returns {Object} {success: true, decoded: string} | {success: false, message: string}
     */
    async function decode(signedMsg, hashedPassword, salt, backwardCompatibleAttempt = 0, originalPassword = "") {
        const encryptedHMAC = signedMsg.substring(0, 64);
        const encryptedMsg = signedMsg.substring(64);
        const decryptedHMAC = await cryptoEngine.signMessage(hashedPassword, encryptedMsg);

        if (decryptedHMAC !== encryptedHMAC) {
            // we have been raising the number of iterations in the hashing algorithm multiple times, so to support the old
            // remember-me/autodecrypt links we need to try bringing the old hashes up to speed.
            originalPassword = originalPassword || hashedPassword;
            if (backwardCompatibleAttempt === 0) {
                const updatedHashedPassword = await cryptoEngine.hashThirdRound(originalPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }
            if (backwardCompatibleAttempt === 1) {
                let updatedHashedPassword = await cryptoEngine.hashSecondRound(originalPassword, salt);
                updatedHashedPassword = await cryptoEngine.hashThirdRound(updatedHashedPassword, salt);

                return decode(signedMsg, updatedHashedPassword, salt, backwardCompatibleAttempt + 1, originalPassword);
            }

            return { success: false, message: "Signature mismatch" };
        }

        return {
            success: true,
            decoded: await cryptoEngine.decrypt(encryptedMsg, hashedPassword),
        };
    }
    exports.decode = decode;

    return exports;
}
exports.init = init;

  return exports;
})());
const decode = codec.init(cryptoEngine).decode;

/**
 * Initialize the staticrypt module, that exposes functions callbable by the password_template.
 *
 * @param {{
 *  staticryptEncryptedMsgUniqueVariableName: string,
 *  isRememberEnabled: boolean,
 *  rememberDurationInDays: number,
 *  staticryptSaltUniqueVariableName: string,
 * }} staticryptConfig - object of data that is stored on the password_template at encryption time.
 *
 * @param {{
 *  rememberExpirationKey: string,
 *  rememberPassphraseKey: string,
 *  replaceHtmlCallback: function,
 *  clearLocalStorageCallback: function,
 * }} templateConfig - object of data that can be configured by a custom password_template.
 */
function init(staticryptConfig, templateConfig) {
    const exports = {};

    /**
     * Decrypt our encrypted page, replace the whole HTML.
     *
     * @param {string} hashedPassword
     * @returns {Promise<boolean>}
     */
    async function decryptAndReplaceHtml(hashedPassword) {
        const { staticryptEncryptedMsgUniqueVariableName, staticryptSaltUniqueVariableName } = staticryptConfig;
        const { replaceHtmlCallback } = templateConfig;

        const result = await decode(
            staticryptEncryptedMsgUniqueVariableName,
            hashedPassword,
            staticryptSaltUniqueVariableName
        );
        if (!result.success) {
            return false;
        }
        const plainHTML = result.decoded;

        // if the user configured a callback call it, otherwise just replace the whole HTML
        if (typeof replaceHtmlCallback === "function") {
            replaceHtmlCallback(plainHTML);
        } else {
            document.write(plainHTML);
            document.close();
        }

        return true;
    }

    /**
     * Attempt to decrypt the page and replace the whole HTML.
     *
     * @param {string} password
     * @param {boolean} isRememberChecked
     *
     * @returns {Promise<{isSuccessful: boolean, hashedPassword?: string}>} - we return an object, so that if we want to
     *   expose more information in the future we can do it without breaking the password_template
     */
    async function handleDecryptionOfPage(password, isRememberChecked) {
        const { staticryptSaltUniqueVariableName } = staticryptConfig;

        // decrypt and replace the whole page
        const hashedPassword = await cryptoEngine.hashPassword(password, staticryptSaltUniqueVariableName);
        return handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked);
    }
    exports.handleDecryptionOfPage = handleDecryptionOfPage;

    async function handleDecryptionOfPageFromHash(hashedPassword, isRememberChecked) {
        const { isRememberEnabled, rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

        if (!isDecryptionSuccessful) {
            return {
                isSuccessful: false,
                hashedPassword,
            };
        }

        // remember the hashedPassword and set its expiration if necessary
        if (isRememberEnabled && isRememberChecked) {
            window.localStorage.setItem(rememberPassphraseKey, hashedPassword);

            // set the expiration if the duration isn't 0 (meaning no expiration)
            if (rememberDurationInDays > 0) {
                window.localStorage.setItem(
                    rememberExpirationKey,
                    (new Date().getTime() + rememberDurationInDays * 24 * 60 * 60 * 1000).toString()
                );
            }
        }

        return {
            isSuccessful: true,
            hashedPassword,
        };
    }
    exports.handleDecryptionOfPageFromHash = handleDecryptionOfPageFromHash;

    /**
     * Clear localstorage from staticrypt related values
     */
    function clearLocalStorage() {
        const { clearLocalStorageCallback, rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        if (typeof clearLocalStorageCallback === "function") {
            clearLocalStorageCallback();
        } else {
            localStorage.removeItem(rememberPassphraseKey);
            localStorage.removeItem(rememberExpirationKey);
        }
    }

    async function handleDecryptOnLoad() {
        let isSuccessful = await decryptOnLoadFromUrl();

        if (!isSuccessful) {
            isSuccessful = await decryptOnLoadFromRememberMe();
        }

        return { isSuccessful };
    }
    exports.handleDecryptOnLoad = handleDecryptOnLoad;

    /**
     * Clear storage if we are logging out
     *
     * @returns {boolean} - whether we logged out
     */
    function logoutIfNeeded() {
        const logoutKey = "staticrypt_logout";

        // handle logout through query param
        const queryParams = new URLSearchParams(window.location.search);
        if (queryParams.has(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        // handle logout through URL fragment
        const hash = window.location.hash.substring(1);
        if (hash.includes(logoutKey)) {
            clearLocalStorage();
            return true;
        }

        return false;
    }

    /**
     * To be called on load: check if we want to try to decrypt and replace the HTML with the decrypted content, and
     * try to do it if needed.
     *
     * @returns {Promise<boolean>} true if we derypted and replaced the whole page, false otherwise
     */
    async function decryptOnLoadFromRememberMe() {
        const { rememberDurationInDays } = staticryptConfig;
        const { rememberExpirationKey, rememberPassphraseKey } = templateConfig;

        // if we are login out, terminate
        if (logoutIfNeeded()) {
            return false;
        }

        // if there is expiration configured, check if we're not beyond the expiration
        if (rememberDurationInDays && rememberDurationInDays > 0) {
            const expiration = localStorage.getItem(rememberExpirationKey),
                isExpired = expiration && new Date().getTime() > parseInt(expiration);

            if (isExpired) {
                clearLocalStorage();
                return false;
            }
        }

        const hashedPassword = localStorage.getItem(rememberPassphraseKey);

        if (hashedPassword) {
            // try to decrypt
            const isDecryptionSuccessful = await decryptAndReplaceHtml(hashedPassword);

            // if the decryption is unsuccessful the password might be wrong - silently clear the saved data and let
            // the user fill the password form again
            if (!isDecryptionSuccessful) {
                clearLocalStorage();
                return false;
            }

            return true;
        }

        return false;
    }

    async function decryptOnLoadFromUrl() {
        const passwordKey = "staticrypt_pwd";
        const rememberMeKey = "remember_me";

        // try to get the password from the query param (for backward compatibility - we now want to avoid this method,
        // since it sends the hashed password to the server which isn't needed)
        const queryParams = new URLSearchParams(window.location.search);
        const hashedPasswordQuery = queryParams.get(passwordKey);
        const rememberMeQuery = queryParams.get(rememberMeKey);

        const urlFragment = window.location.hash.substring(1);
        // get the password from the url fragment
        const hashedPasswordRegexMatch = urlFragment.match(new RegExp(passwordKey + "=([^&]*)"));
        const hashedPasswordFragment = hashedPasswordRegexMatch ? hashedPasswordRegexMatch[1] : null;
        const rememberMeFragment = urlFragment.includes(rememberMeKey);

        const hashedPassword = hashedPasswordFragment || hashedPasswordQuery;
        const rememberMe = rememberMeFragment || rememberMeQuery;

        if (hashedPassword) {
            return handleDecryptionOfPageFromHash(hashedPassword, rememberMe);
        }

        return false;
    }

    return exports;
}
exports.init = init;

  return exports;
})());
        ;
            const templateError = "template_error",
                templateToggleAltShow = "template_toggle_show",
                templateToggleAltHide = "template_toggle_hide",
                isRememberEnabled = true,
                staticryptConfig = {"staticryptEncryptedMsgUniqueVariableName":"e4621aba605be5e1e617abdee023454d79930eadba2f5da74282bea4e8cd3f34fec533daea312c5ee759de19848a707d8e99b360a0dd1fb917cd79d138764f67e329b31a2b7119e3bc35bf06b971129edc4546056aec38ce1057e4fec19b8586c873179deb54adb8bbb2ada622508c932685166e6bda447fdc4600dcfb0430d1826cc37c320e2885a3dce3b07efa245bfcc6904c236ee7931d868ab086cef99f982cebb42d87ed51ba687ddc34ceefa02e477db0714d34baf7f7cd27cd7843351252a1eda2f0aa405f67c0540f215f007c2f492cdf7fd949ca5e3caba75d09fa2c3804ef9aefa31c1c5ecd6c57383bc59f921c316a6a8603d21a47eeb517e4b4a72dac4df5d6ab9f097699f504b93904bdc44cd7a50d5fe26675dd3e8bec730d68dad09b7d4c63919b0f22f881a294e53e30f628971e68f422ae7868588160d58cd65e5c02dd506a2d0ea419892bc604d1ea31a326172ad4b786061aa77fe9f46c5d6ab3da00254ae61eeded1571d739bba258e9601e75838538b027bd2e57f0aabeb04402e299899c4f07be85542a7193675bb8d500f5522a516310989e64cabe598f86aa702b42de2fd81dbb1ce325fc3a8a191caeca4228e1e8c83ae55c1192cb1b088e591a518a54a0e0672893830335b3f45fb8197abeb5b26627cc2037b01b02f9532b874fdaf72da93b048d2fabe4ee84b46716f6e938e9ce195a9fac021ff15b4e5b0b4fb9ab00fbd35eaf6f3f9242802174b658b8a6f5c5bfca2ef1b1f149cfd9487489986559dbe9e970f85a3ff0e805f3d6da14fcf9b65b818a52c0de625425137b7c260029d0c15407887c781fc69d8f62a70678b7e40e2c96ab50bda2d9519ec45388532ead58825d69fe90e7313abc1e85c5ec2bb9ecd233a68a9bac559e68509fea498edd7b27c66f057f2afc109cff5d58269b4781263d5940c909c0836fa93ee372544aa31df7c2c016555fff78336b0f719a3537d685b89587b3d5882ca61da6e227c0659406571fa19ac0990d0b582da48dfcefa88b9dcf880f0bd7fbb13e9f2bf40d7a9bb63cea3e7991e25066f8523f8e09ce2787f1c5c64c41a5b9bbadf802f1854da88f6723d086e411c56070644fc9a199ccabe8d529937d8c8602318a22bdeee4886ea2c0664b3d8080d1a8a6329de277cad8ef2edf9c8310dec729f1de447074d5a1d03c4d1c749e0e43c839c2ab2cade0af871a9edf3b44ecc65ec24aaded86a43227be5d264c0228bf2828adfffeea39e53a4aaee1375b6741a0831385f8d3b586184a6a169041d6ad870f9bdcc9c22d36aad3136fbf9521e38501e31ee795cdc5d9dc308d1cb2c35455d6e2fb899ea9e14c581390fed7391046e7965a5faadb267316b665f29478d03efef760fa962f22f03ecc7d3a1dbce4864794383c25d52c11116ac23083633286a17dfa0ec7a6d81d2a02974facea3f47ad7d37eb2bc47e8ae404834d63eee303b32ad823c8528c240fdd991631078ba13666f038ab1016b0b5e9af197e218a2b559ba85a78c9280420c5c5be5a615eee630f9b807fdb6995b55b141ab4a3c53d737f939f7806e1d2cee6b522a99fb2585aedfda67248df730479e3f0e25b5219ca1d1926721aab34b782b21ac22fa00f18c2bbd73e9542804c4d9f5efd29caacb872f9ae20bd1754fc9830740b4a910bffebb459c8b7d62ba1bb90aae48769adf64a9b2f3f9451f137438e68bd6910a99bca7a8d8d54896d5893e5692688ac3be006a33597bd15de25443ba14f206be78e2e6cf3d32dbf3ac6ba1b9e8700d904c98fbdf7f83a70c3249eeda392918b49493439edd9240f7e79a15c7ffe80d3e960046ab69b1b6bbbe05c2c97ff156da0d94dc95ed70e8de35143e17ed93e434880d808540496936635e025b7695934e1250e54c9983d916916cb24ce1bba8a3359bbb2c466d9c97cdca6670eb94102e95035276d2e1d6b6629998d3cf6093c7bfadab76227c54dba92620ee312eda6a36a8a663d0671eeefc48ac94d26c2b488dbc70e53a68ec03d75978285383e05bd118fd436cd0d8c880c52c46fd379410c0a36804cd351cdcda08de9ae92dd9341f46c0fe7e00498d66fbd7b9e2eb883c1083d6a4ade7e9131b32bb240c79217efdccd83f379e20b59df364f4aacde4d21fe350ad362ffd1662c4ad1c03031bbd284c858fef079ea1c047483b7262a5920a372c843b4f86f88dc60814a55f24c489148f614b3bc3392d12627d3618ce1ad1c449c33a0f3b12f4f68da60dd37f84691d885c61c737c2189475fefab51b7d331c97037f6c5c089027a1752acde4da9691db29790c647b5af9ffe26df47e5e0558084b88c1a6029b25f0a7426b0b6819987943b9b2e04d28f4710b6479a742014c90c25b1897b4155b25bfbfffd6837d00ae384dd6980745f14bddcbdc955fd90e9ec7b3951656d90ac0b3510d541e83795d7482e4a92555d77039d40110bdcee512f0172ac01329bf2325e6f54062e3126827b5a50f8411b7525408eccd54dc8da9c3438be2cb12ea3a328371abb1346b5165bb884307da63d11a0081dd4917fef4a3c6f2ee517c45c783767483de3195d817f7b9a63c407ea96388d21dbd625cb9f727531a81ac00295125d5d1aa084abe0c27bda4dbac29228f0041c21c3dc34c12d02f7fb6113f821b5a8b65a875941940b8d432af70f9d745fccc5d31b61efde29348b96dd9b9bc852a82af8fc280cde4b7fd84a14a94ff80c1f3dde65472eb8bf9f4406b3cf370e0ed0c22ad4fe2996755c8166ed31784a2078979a82460a93db76ffc0f298f6bcf3e92ad4b846d2ec25c42cd4845cd7a1a8aab300f267f8f80c71c712c7dee7ed86302c1f99ea8a5c589babbff3f629ff311ba627d2f207ae75fe1aab72de0e9e4cd2606eeb0aaf047458b37917e7e7dcc4c01f90a8a0cbc812825059d0c759629940faeac4d8bfb734e5c64e6d83c0da972c0ab2185e8fbd30d96bf971f43cbab23afa1e2d02a4820c41689ef59a118ece36e1f626ba1d3df4f3013710425777e8631dbe0b007c10f09d1a0921b4ff85a7de1100a990198f841f269176cc2e26562af4ae4f82222d56cc63e6a72a0d1781c6314fcc794af6799597048cd953e352bb5dae879cf44677ea7a68b308ee66e20acd2c80548d5711813ed50b4f43bb71dd3538f191dab861c3096b7869116aa969bbe5baba3216172111a76cc23e97435d57206e5930cf21c25ec0b8d62156ff413d9a80e517167d83ee5bd93fdd027cc4522643cf43d115113694203a27265b94f0a2ee390030f5ebcc85f300375cf1aba087de42502d53e969fb5c990894ac928ed2ef82eee5d9d369df9ebbe687fe0e8792ea54ca703f99f5404d6b89cf8e687f4f198d97d6b68d66b531386cde9dfd041eb1ddf7395fd10c66fe040811d1ec6dcbdba120c6644946c0504623f54368550fdbae5e676170909e7a94db89c4d379006aa07e5e36283d17b7938a3fe09f6cd46c5f74ef51f8f02478502ce6db60fadf748c4f5271bbdb8d11e789c43582f6073ff3d463f045098dc634d5276fd3ee8655023d596348d8e114ef2c8cf3bac62d40db4b369e707d1eada52c4e68b9ba3a530011d487409b2167533b2ba4c537b84734f80f926bdd9da256ea707403b660549532b30c62234e9ef28a0179af676c98cdc09fed04b9aea930882a0a157136bc91a84c487eb68d6c62a3973684562abaef3ab43abaeba9d8520769633a3b650fc0bce487a647461dd5f86ab0c535f174dc8f443de53db716ed9e0187e291f3faefc552b7437b0202b34b51edae030682073658c653be86c8b203825ba2702ae1a7a085f389744a5c0129b907ebf7fd2edde7d3c2701280d783e240ebf60db550fbba30d418c375ce9ff5ff7ae9b0c6cb5c10417646a6b3a4712f9c1282f7edd7cc8d398c2e1a9d3c2a7224e6b8fa796c7f77d6c648aefd7f1e651497b981daa90194fdfb12320791eb659590294e1028afe17108798706471fe9d8ca3e73965e563f75cd1c6bc025351ed3c804c76dffabe43b799418da6c899db5b0d081b3c774b35458f061dc2d39e0b2c196bc2ad651573f57fb5450befef069f1d3be35d6d754f91e6889d6591671e78f8c11c63325a8a32c1ea44879fadf6856896e0556520b56ac7cb51ee7077acb29cfcf4e63dcdbc1cd28efbe541ab151d14f37d50e235e4806754a7174cbc736dee44db228f5b9eca66e51de2208a9d7e5de0eebce33bedff3bbd368bb6baf5ad18543f11e4f3e0379384374116ebbd97b90dcd46a9a0b303fde4ccd9b4aa80935dc3ca8b91c4ab75c0ba75f00fa12a319d43439fcd6c890ca5d7679c7f107ca57883cf01ffa1ae4c58679a290fb92e009339561054451a07421e9e43f979fa97a7221bad18792dd45dfed62dd71b6c7c68b9595188c4579d8cd66ba6a68185b46154926c4522bc20937f686f45198d1f2cb77e11028ab5ccf4deb170e9271a33e7aae739a46fde9e369c3ea3b84c7eb6e816b2993d7722a685092bd6908c06315e55032bdc3b577edbee05f2a4c79ce17e2096da9a85ddfeaf9b438bef01c0f1ac5227916df6727f1d21c07349427673bcd3317adabdbbf2f586693ec240a060c3b9fe134bb7192818885dda7574eb189631e2356a3676786f8e465fc4229df78bffcbd79a5a581c15b9e5776097762283ef26d18ced111a97f8fb15f7615b3c9676485165c76503f06ef2fd96c58ee7ee890c3dde657d74b3c98ba5d1a0558fa45836ee048a72c49eee18078db20c1ad6811caed0c6d61d2c181b5a63bd1da335646e7f869949132df2ace9ce6b478e5915e6978d3d0097fd98d8f10f232fb72a5b2c125d7e1a88f8b24e78998541a841d4f403130ad073be97c8208180bfa4dfa9848c5428765f2b1ed98ee2b497b30c27f6614f52c76ffae1c280d34d5e171cdad12e3c4f532d827dd4cfaf336a4013dd422ccc92b6c058697e23b204bad2644f2ac2a613fc6a6a2d89bd9d1aea193f4f0eadda48e52290ec9773bb353ecd695ca0a9e33cbb891a48f2238b68f6b4e69466ce517205dbb6714566cf7b570bfaa93d1bab4134bc2c82010f74addc2b0f32c5d45d87da065005b34ddcb87bb55a8e44de427a1ec309b0fab8de8d0da02f709282fee94c406a673d25c15a514a39e4f4f20e017729ac85b4a698eddfc35a0fd33c749766666517de9673fc15b4ff0ce03cff4a0a1b08cbe4a0cac4b48475747cf9ba6b223598ed329b58c727b8ca8f820eff4800228dc61df19567bba535021b00014612ef158f56e0633c2763e5a939feb20a6977e78a3cab9752f25714d7cdefbae4229e22aa14eb077b1058217328544e647d7f0a65b2181e145e96f958679dfa9715cd1c0add3dd12e77ecfcb097fb43b5cc50c68f3f035550be2c516b7d9e6d2b61320a0de200159b53b5f5564ce39de9576ae20b8340cd4bae0d294d5d04825b8c0098f1ee58337dcbb270a744904a6c06ec46b9d125b92028c1be3cc0eb576e2735019a217c698840f1662d02cc73d111151b45b6700e3f77851bd87fd80324c87f67c74b708fc79199af8f6b3d886b23517dbfbeda71c71272f64168481c5c811bbc9cd7935b2acba867ca4c90bf73308bb2ea167109a9975a80aa8fad1240308ceb7521563f8020e96d89d9817de8795e98ecd4c0b9ab3d33d29ed19b3c56d399ef6e34f2d552f337fc2e08046d1707373493f659aabdd1dc198b35c7271dc5058d3fa520eae8d7f39529a723d4a7eebabc0fbbeee5922ae94859fce8d62b25ab6ef26f11e095d044635f61048589c31e69d4b3b77591685338a8bceb36957ad52baf4b4ea905dc8b1174526985b3e08fcca2246d4fc1472f366642867ba618cdcf87f2d9d55d1cb00dc1fae8dca07facf6c1d437a66bfe83161843dc30c0fbf1e13022ead55730674606b2b1b0e5ba79b4a93a569f20af8f1fbda115d94836a4b82590249e1bce5c8e49e2652a6ea5f9952c4750abbc3e2158581c4cd3699fb4ec3f1bee3d9faef88467909cca3323b6a368f3e72d5af08acabcdc9edb286a30a876acc6ad292940114312c3aab963195e2b2d80beacf1b89f212ba590579d02bd20d17ccf96468fdf6611b5dc248a70db1edebc97e6d18b01d4698402d4ba3e6424df1aefb59bf7ef49f89d7bd031798a7fc5bf04aac3615291854ba4ba320f959764e0d92208f103f097fd24dd2300f5b7218985f0df777336e20052f9643a51fc68e2066fd87849790b7cb68569e88309911766b0361281674af57b5d44f80ee57f34d968dbca0b6ad53a508a76ac58debc47c915cc6ee9fe0b54ccde5b0204bc123311d801482c18a8f2837956e06c2242125948b0b02ca1858efb540692f7635c6316a873dc15e238cd81f31e82364e65c7ace924d853e79e0ea32140e3e97c40a954b29a747cc33b33926b32c7faacd29a2364fd2865815e37299b83e3aa1ae0966019d2d64230900e3048b9d01b19a4bddd46ea125686ddf8aa6a08c1ae34cfc4e921e0d7ff7e540f44691209ae998d9e4122cb7a20a1a25c3a72c3b0e0f6cdba67e6522c32d6f4990e0123bda2ca16fda54de9659e490ff0f537a74c9e26700ed716c4d6e8d6c3db93b236e48fb72cea6ee032dc03077584e9b1e87fd8316d73d8cb7756c0fb7db53def1a02a9b235569746c5c9601bd818eb38267709ca6edfac90fcaa81f30aa1465482a3c9e91c9cdca8804602bc826f8b118f45006cc15e38c1ea5b8e03a10dd02aa6d4e2a31a1573bcf0ec01ae6543afa169d1399ed7ee4d374fe999150ed14fa568584d0bd9ce2f93e13c1a3862059ad6e4ae9633870b0316bef9aa02d5fb3367b35495e2e5fb8760b2a804e4143868558dff9e9e267998c3558b183a2dc8c35bc91dd8484135e728a5a2f74c1ce71ab99347b1a4df1175ba598c385fef2435cc4f8bccf02337684970113f0edbcd811db6424d48fcff59968192ee42e735d26e2c9523dc32b493957adaf6d6a6d2a52141c080fab0b381ba77e45f585e5f405075ca6e1ea27358be3c6d424bff06d1d2bdc44a759fed0aa070703b4877e2c3ca47ab814bfff1ec4ff8b1a5329fa3b2ef0fb95ef4793631adb0eabcccdc96b50dab6ceac6c72e0266a590453eba9ac6077e9d81b0d67a562e133b1ac6ff19f0631628e097fdbd8496febd57cb753168bd632f6a86a274573a666e4f59a28670f2929a7f72f8ae848392b97c0547d1db4844b3d9ff7201f58ac1a308fd38c6de744f8dcc599ad5305e6808f62ef42d7a5f6151b2215ccc3fd8d8bcb8eaec44f621335cdc2a74624d099c4be57b6ad5829670520412e9c7c3d03ce584b25e5d23feb5340ba78c57d68d076988bf05329e02f6434b0d9abd56d7a29faf7511c4e9af3ef50b0ce78c690b99a996182ddf9eaef1bb2297ca42332d08c59d2ae0706bb2e50a067f1ed7e584d98e94e453a2f85739a49bf2bb55fa86b7dedd2f7474e20be92efa1fe612ad8d7fedc1d62bc14ec77e9167b2328fef1b9aaca269e459d1270d018e155ccc08807b4da89fd6f4a4d16f3f565a6d3c8ba2281a2ce69ce6c14d7b9964a4d8c5581655c0f98139ee2b2d0b1f437107e04eaea5461df8ed665e53ecdd12fdfcbe467f582937e4387d2a06e96857c27a665d1093f1670940d2186cb388a1830da5ebf810777dcebdd2824f445d9574bec56bd5a93ac7fb5b8aad71c967cd88941986d1249b52096fc9972a96d17fd69e8fe4f0f299cf036969b207d5331b2268cbfac9baa6cc7f25e4c8221e053a778c1a434ca30ef4eb9d27119859a7abf3ad937822e5eaab2e53624926765eb3e07ff6dddf838a4426db397dd5f5fd4a3865dd461c41221dc2ce58041b68ad823bfaa6d17b3045e5fc6dfeccfdeb4932bd19d69a6b99615fe982e383acb9ce408fd8e2543f42df4dbbb20a96adc6deae1588e076b9f5d5a4eccb1487c10f84186a4f144a51cadab87817bfc93a5f8ac5883a2a4c23535d0ce4f28fe253bfc5b6b8a407e47d2e025daedbb92fdd36d4a76b2a29099627da3f86cacda668aaeaba7476c8fdf04f60c8164fb4b24e8faec2b34f4d081ebf1a41c88731fa233c9d25daedc724e1f6e36cf7f5913b9ed2953274e100318039d7a84c10218ec859df4acbda94101598725dcf6c6153a02b92909705eeccbea6e6b7357f2026531fe01c8d79fdf8aa4e4f6ec9e626b82a0929a4fa24f33fc0f56fa82519feb8131eab0f20b923e59f402c1eb6c4f8e031daa838ae065e63dad74166beae81bfec85eff6f44988a41ca189180851a4249c46e9b1fc256d5bac7521c7ab551aa38f6fc6508b8b7bfed630bc961602f8a4401b219dc5f8aea7fd54b45b20305925a54626ff1e0942bf52bceafbb90ea076a7f7b057ddcfaefa27bbc0387e97cf2effca40e067476cc8d91404c610ed4f88cac95330be20bea2ec387fc54b29340ea4333c697c24a05ddc5c9533acbc0b61134bfcebefc50569eceebd7578c5573818da7cbcf417a7d62f21a7a04d3037137df7c9093eab6d9b3d627f1aa740bd9d0ee0be54043df10b5eb96a6796f1cd156241697cb10b62e3e7a0e6beb822e34b0689c83fcde7bcbf2d5a11c4cd0081e382ef53606234be2503b2f7b1a86ec61ac7d8afab560300f4e08ff7c3aef3a8b05262c7d6cdd3641add53259e136f293f1978f54fff7ef5c826511d56e477f659aad1bae47c3142250490ee7c6f286cad99bb0d445c931a2274e7e130baa33fecd5e6c97a5c4c27cd54a51b82ed816d99a9c7ee56f424017574dcc65ef32aa3833a12972efa0f55199883825c4a668d58b45c1b350b0cbb619ada532c3c17a36f6cb7f5dc579e231a62b7c91abf0c6d722dbe5978ab69801cda7d34e0963a0af69920eb10fe8016b949f24bd0ce684bd2b3ec6d532c35588c9c18f0a4f2afca96d073d84d31190d2e55f156e7cc9a572b5e50d6c76c3351a29dc1e9141f339e441cc1f59194271c7a707953367ae2841161686e51fef8350a9f19a289b32458c75931cfb33f0503116cebae5367a1965894eb3527378fb5d052940edc69808a5cce1bb652f90296dd8e5d77b44bc987e5fc532c309100a9130d18783a65e1b0aacc8ce3509d15ca4d5b615be488e00dec89f2c3d546e2e99dbed4739975fac4b42172e56347413d9dc11d44d0490c52d453d4271055350fe0659e5d934d3489eb93cd3638d81788f6903cf73de204bcf9331ba3f2c59b69560e24f343a6d42aededdf6398f5510e072c807b1d8cc07321c4f4221ca92f3ecc4ed74f0c64e9be6ba722293f9844f6449b4debabb0f338a6a3ecc6c16b9448d6a64a203cd6f8621dda23b299747bd690093ca370c25191ab831d44c7834b591c4e9554e57ab4f076482b5d299d7b292ae93652aedd2b7bf2273529e72e0593ee72abefc9342e05c99ab5a3289b1877e4b3453b955888a7acd07ab60827f3f22d1e1f2798601aa31a17e4adc0fff28d59d1beb575d6b0b4869a3c9d2adfe2f0e2aed19934e3dec96ae157a74ca8c0712ea2e7e0c226dfff587166109231718404e2a8700dc00db69bb8f939e5922651f55ac6874e8f238771f6a104f5d5dfd3f228ef41ec8ab81cd14df8e5caa959652f01006d4b314a64689b2ae4a6e8366e75324bd36defd27d9362d4b4518751076d5c9b1626c8f20e1874f733917de90979368909a487da1c5861519882003fa5e0538a11dd97ea1296a0b3b13dfcf13393c658c4110cf632cd04ae1c3051f20c5e444bcb0f188f4a15fea8932ba268c02a2cd09a182d2caaba8d03cc6668f747bc1f92e3bc2da0a8f8cd74551a1bab14dcec738d09ef8c36f687ac3bf06608ba96ce37c3385d0b775b8f725c8dfd19f947f6f785f5667917214ee1ac29b0aad337fbdd05e23aeb919697b77b2e977a108a16ba110381295d699396073693702c38816696291c57c27f1a2c41ebea5de374a961460068dae17991cdad9e12ecf883707d4228be4b3feb1e907f481e0c478a893267d681e7bd0eaaa488656a76dd59c104873de5596901ba482f8369fca6be2501b6f042be7d739fd71b60d37ca7015609f5a9bd71a9d85fcb16b73c74e0d6d00ca6ef3585b7a03b1322517bca1c83eb1c8864f5ecb80102bb11d1760172200773d567e3a226fe74e56d79d9caa955426acd6d8be917379c12719b1bd5fc7dbfcc613ed2eb4cb514a59fe063e8e5ba4d8736b6dd077ce2fbdbd793d63563893cad20636246635043c892e3a69c6487745be01cb59b16e7a3d271323d42856789d69370c139af5b17152d3a423e8e2747c28f0c80ef6af88d9483e25d5b19e4ef0431d430e40b7df6e68400aa841174b4bc70cc870ea16d2e0b8035959a1f1d6d214cd5dcdbbf5a181efd5bd2857717eec899ce515bedb38ad0a65f0d1de36127a51eb82327a8d5d0d29339e070013c1ebd7d8d7019d16a41d71668c838acb582c081dc9c794fe20ecd58c6865440358f292751943d416e4fdbd68ffc06818fd81a593507c5f3a8e8e6d62b4983f1f21417d7450bf576324da8e28ad189674a86e97d60dffb647c7f6c2282198a6e2a3acc566aec1356e522b6f832e9742376e9b510806c4453b7a75972e87a388ee9bc49af627286197d68bcd0d81db60647d66c69edf31ce71dfd14e3650d141afdab96d963f3aa1b46a2c6cbda82ee83646fe2f28c68a32e89f791246f8b09cf4658e1ff7f6102d2ecb41af480f3a8c2a8615ea4596872a45de61b6218b8ac7be85150d9705fad5c918e2aa6a3a9eade2218c236abee525f245f78230891f0c99cf9b6bfe4e9cdbd388b34112a7faa1ba34eaf8d65061b794c0e0bb1b10102fa30c431ff7e3875e8c55b9a5e584866cb5a9c67f5728b983a792dc2b02eb76222c2f6370a507261145210415a21039d0a74fbb4ac1d582196a8f32c3170d27bed440d1847d875361c9da5e8ae08c216f135e62630d565f360425358b4b6245ff4e7adc1664425c92fd277ff2afe1e179ef27363630f28b91476cf975360a56743b83258cbed53afe0a4f82bc3b42c2779fd65b7e5793ad4944f119ffef09c3cd0d49ea77f55ad721c79768ec099159ff1f353c50bca667767917b754eb49ea9fb584c8dc6946358891cf22ed66365121fec0c46ff650986b51f3c08e4f11f7f25ca80fe3dcedb6f46579c45f11ad6f498d5c6d94035a7a3cc3b746b24a39e83c9caeb30d3da96a98527fcb022929723722f92617c158ee8e11d92d2995a7daf36ebb18ad14ea715a5342103082fa6f188fb597692dc43411ac3996d6c43c362a4ffa4f026b379910f2d72188ca7914c4540dc53d83af7aa08ee503b9b08cc4215875af4d50e701ee0565b757321eda03c8542c06e390e1254eafc9983284cf827492b90a110ba5861d45e52f9efa6b5ac736e280055203328bcf6d88c7ed70666706944d8b461b2af981880951b42fd7b9d180e20a833ff0ae64cba0b7e6042b9dd9522374c5f738aa965619a2aa6b2f9c39b1b2605aec40130fd9da50a87d4ac8b6f79870a741ebc8b62fa57fde65ade980f11cae1e1805455d2980be28178d3dd5e783d29bb41f3b7bb50c72c14530a6c113a59b8f64f9b4890fa8634e354a44d31d7ed51e848075ba608717a50bb3ae20fee63c5c9e4938475e266ee4a3c5f0a720cc5f0bf242e90bda6361c1ade2662001600df9d941b5df6acc4fed981ab2b82e9ee318431f14a0c3e987af495f318d5b1e7abb2969270c26d583b4acc9473f4c7626d41b3aec3b576e468a4ff8f221c1b77e1f333078e65ac7fac4eded84b13ec6a0df78646ff60989e85a69ff5ec4eae2e8eee6ebdb9ea1b82518867a368de7084ac61e7d6606a673529144f3fc62c79b3574a46f884c58179555b3ffc5e0120a970a51230fbd37c2e27202b57254ed1de95385793042d932920506e5a650268af9860e133a57765593a55ca7841dc507631be218b7578b52d36e4fee2e2440c4502462e193cfdc7a13dc17841b0e69a87d7251c895ad762182afc1ab053f99de821ead018af2748f706ef138e48ec34287b3b9fee05a9ebda7af19803c32c870df8d2cf2636d1f6baccbafb901975e1765dab092c55710e02e8ad5e50e6963f596f8f4c22992a36f159ef17e9a9557aa0d5206a03831d8c9c90c329eadb8881468c4d3193b6e4d4d870acbe4e6e8960b0e146ab05a64aef8baec502da09c8d7c71fc73a4444eda278881ee66f1232f1340d53118a927675eea042c354a3bd96a9d1c4c46e6141ffb7371a35d95de86e23f54cb07be0267018d37948bcc4018e2b4f9dd96036ae6ede48a2c2b55ec57206bec285cb5f98ab6168b4d3419dd162f751c162ca767078f44d2fc359f2066da892e773be187dc84315c82c6edb9f18868fe85a44ec343c6849c47471f1ddd8d8d569676e5d59fa22561a137c379a202eeba740a9a2d5ca15559a4f37cf74e104a8274dfacb8fcbd5299abb0a99e2d719287c5b75e7b98908ddd8771cd72a40ad1a61be25f5e30c3e85ee0c528727bd0dcdd6325251fad214f97b07512df79aa6d3b388f7046776da1f68352ea67a4462a52592a001d6aae3caa17d92398bb10184464e3ee4352f745bcd9470ddc432484c83a278be63c4c5c05799b1ef506e1224e5478b449dfc47516263f8440e430d16304ea6e655924c7ad3fbe1fe36e3f34246b6a4ab315fdbaebc4b293d1951daf51c45431c373680d405bd4efcc418975311c19f8de6b4474569a95978db9155aa5530b58f6e48d99465d7005351812a69fadb21e76d075020a31fa56fdcd694fca2dae9812ab2d64a055d85cb027685a7fee8b1ad62053b5bae92ec639efca79294e553cd5f21e958cf515052190b5735228681aab36c4754aa0b3f0c73a874e31ab3f8189e6f54db58c277b84632027b2564f05821c2a262f6afb935d802b1d58a2ce43576d70dd6865a307bb5a59c901376120509c44036bf507b6ca4c8a94106af372ff676b313092ea7dd9ef2f7c7a59ef3988561bd81fc6985f9ae256f8a0b28a62a992d14921453eafe57e9b9b5a01a45b53200e57331a9d608359c3ab07f9189466fe872ecb32a2f93972b92dcd29d5c1c1e5f69d1365a36b8f32e791f0d0bf7e2fec231f8d149cd90dc73b0743b60e7a56636b6e45869c206f95df211d7ab878587b06657de840db7680e461ecec410ce86c490bb0a52cb7c01439e3b09e7b1065b04b610d6150be0286e2d35becc7c0aad9e645c4c03f117e17dd46c52b29b394347998323ffd56e386e634391ff75d2819f4ced3f023ac988a708873c0f151dcdb1ec62eb418fd11005fe70ffe6590c8dc672ec9bb98300bf8763c90e424bd611d077c9a952116c1a4356d241fe3081acca253b12c14949718743b4ab44b60b4e8b9bcbadef08cc9902b58983f8dc5f310adc76c51864799a98f2631fc7c811156b92fe1f90b6c409009a170064641632cf011fdfd78c0ebb4d908d3f3472bd71e2191f7c0ba0f8abc17303974210e95e624705e2d6e658a5d380d00aa97d3fe5b657f6d6caf4b","isRememberEnabled":true,"rememberDurationInDays":0,"staticryptSaltUniqueVariableName":"80a19b927781411f2681bc3b9dccc1c9"};

            // you can edit these values to customize some of the behavior of StatiCrypt
            const templateConfig = {
                rememberExpirationKey: "staticrypt_expiration",
                rememberPassphraseKey: "staticrypt_passphrase",
                replaceHtmlCallback: null,
                clearLocalStorageCallback: null,
            };

            // init the staticrypt engine
            const staticrypt = staticryptInitiator.init(staticryptConfig, templateConfig);

            // try to automatically decrypt on load if there is a saved password
            window.onload = async function () {
                const { isSuccessful } = await staticrypt.handleDecryptOnLoad();

                // if we didn't decrypt anything on load, show the password prompt. Otherwise the content has already been
                // replaced, no need to do anything
                if (!isSuccessful) {
                    // hide loading screen
                    document.getElementById("staticrypt_loading").classList.add("hidden");
                    document.getElementById("staticrypt_content").classList.remove("hidden");
                    document.getElementById("staticrypt-password").focus();

                    // show the remember me checkbox
                    if (isRememberEnabled) {
                        document.getElementById("staticrypt-remember-label").classList.remove("hidden");
                    }
                }
            };

            // toggle password visibility
            const toggleIcon = document.querySelector(".staticrypt-toggle-password-visibility");
            // these two icons are coming from FontAwesome
            const imgSrcEyeClosed =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA2NDAgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTM4LjggNS4xQzI4LjQtMy4xIDEzLjMtMS4yIDUuMSA5LjJTLTEuMiAzNC43IDkuMiA0Mi45bDU5MiA0NjRjMTAuNCA4LjIgMjUuNSA2LjMgMzMuNy00LjFzNi4zLTI1LjUtNC4xLTMzLjdMNTI1LjYgMzg2LjdjMzkuNi00MC42IDY2LjQtODYuMSA3OS45LTExOC40YzMuMy03LjkgMy4zLTE2LjcgMC0yNC42Yy0xNC45LTM1LjctNDYuMi04Ny43LTkzLTEzMS4xQzQ2NS41IDY4LjggNDAwLjggMzIgMzIwIDMyYy02OC4yIDAtMTI1IDI2LjMtMTY5LjMgNjAuOEwzOC44IDUuMXpNMjIzLjEgMTQ5LjVDMjQ4LjYgMTI2LjIgMjgyLjcgMTEyIDMyMCAxMTJjNzkuNSAwIDE0NCA2NC41IDE0NCAxNDRjMCAyNC45LTYuMyA0OC4zLTE3LjQgNjguN0w0MDggMjk0LjVjOC40LTE5LjMgMTAuNi00MS40IDQuOC02My4zYy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM2MwIDEwLjItMi40IDE5LjgtNi42IDI4LjNsLTkwLjMtNzAuOHpNMzczIDM4OS45Yy0xNi40IDYuNS0zNC4zIDEwLjEtNTMgMTAuMWMtNzkuNSAwLTE0NC02NC41LTE0NC0xNDRjMC02LjkgLjUtMTMuNiAxLjQtMjAuMkw4My4xIDE2MS41QzYwLjMgMTkxLjIgNDQgMjIwLjggMzQuNSAyNDMuN2MtMy4zIDcuOS0zLjMgMTYuNyAwIDI0LjZjMTQuOSAzNS43IDQ2LjIgODcuNyA5MyAxMzEuMUMxNzQuNSA0NDMuMiAyMzkuMiA0ODAgMzIwIDQ4MGM0Ny44IDAgODkuOS0xMi45IDEyNi4yLTMyLjVMMzczIDM4OS45eiIvPjwvc3ZnPg==";
            const imgSrcEyeOpened =
                "data:image/svg+xml;base64,PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHZpZXdCb3g9IjAgMCA1NzYgNTEyIj48IS0tIUZvbnQgQXdlc29tZSBGcmVlIDYuNS4yIGJ5IEBmb250YXdlc29tZSAtIGh0dHBzOi8vZm9udGF3ZXNvbWUuY29tIExpY2Vuc2UgLSBodHRwczovL2ZvbnRhd2Vzb21lLmNvbS9saWNlbnNlL2ZyZWUgQ29weXJpZ2h0IDIwMjQgRm9udGljb25zLCBJbmMuLS0+PHBhdGggZD0iTTI4OCAzMmMtODAuOCAwLTE0NS41IDM2LjgtMTkyLjYgODAuNkM0OC42IDE1NiAxNy4zIDIwOCAyLjUgMjQzLjdjLTMuMyA3LjktMy4zIDE2LjcgMCAyNC42QzE3LjMgMzA0IDQ4LjYgMzU2IDk1LjQgMzk5LjRDMTQyLjUgNDQzLjIgMjA3LjIgNDgwIDI4OCA0ODBzMTQ1LjUtMzYuOCAxOTIuNi04MC42YzQ2LjgtNDMuNSA3OC4xLTk1LjQgOTMtMTMxLjFjMy4zLTcuOSAzLjMtMTYuNyAwLTI0LjZjLTE0LjktMzUuNy00Ni4yLTg3LjctOTMtMTMxLjFDNDMzLjUgNjguOCAzNjguOCAzMiAyODggMzJ6TTE0NCAyNTZhMTQ0IDE0NCAwIDEgMSAyODggMCAxNDQgMTQ0IDAgMSAxIC0yODggMHptMTQ0LTY0YzAgMzUuMy0yOC43IDY0LTY0IDY0Yy03LjEgMC0xMy45LTEuMi0yMC4zLTMuM2MtNS41LTEuOC0xMS45IDEuNi0xMS43IDcuNGMuMyA2LjkgMS4zIDEzLjggMy4yIDIwLjdjMTMuNyA1MS4yIDY2LjQgODEuNiAxMTcuNiA2Ny45czgxLjYtNjYuNCA2Ny45LTExNy42Yy0xMS4xLTQxLjUtNDcuOC02OS40LTg4LjYtNzEuMWMtNS44LS4yLTkuMiA2LjEtNy40IDExLjdjMi4xIDYuNCAzLjMgMTMuMiAzLjMgMjAuM3oiLz48L3N2Zz4=";
            toggleIcon.addEventListener("click", function () {
                const passwordInput = document.getElementById("staticrypt-password");
                if (passwordInput.type === "password") {
                    passwordInput.type = "text";
                    toggleIcon.src = imgSrcEyeOpened;
                    toggleIcon.alt = templateToggleAltHide;
                    toggleIcon.title = templateToggleAltHide;
                } else {
                    passwordInput.type = "password";
                    toggleIcon.src = imgSrcEyeClosed;
                    toggleIcon.alt = templateToggleAltShow;
                    toggleIcon.title = templateToggleAltShow;
                }
            });

            // handle password form submission
            document.getElementById("staticrypt-form").addEventListener("submit", async function (e) {
                e.preventDefault();

                const password = document.getElementById("staticrypt-password").value,
                    isRememberChecked = document.getElementById("staticrypt-remember").checked;

                const { isSuccessful } = await staticrypt.handleDecryptionOfPage(password, isRememberChecked);

                if (!isSuccessful) {
                    alert(templateError);
                }
            });
        </script>
    </body>
</html>

